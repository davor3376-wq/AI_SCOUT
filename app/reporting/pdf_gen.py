import os
import glob
import logging
import numpy as np
import rasterio
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader
import matplotlib.cm as cm
import matplotlib.colors as colors
from PIL import Image
import io
import qrcode

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class PDFReportGenerator:
    def __init__(self, input_dir="data/processed", output_dir="results"):
        self.input_dir = input_dir
        self.output_dir = output_dir
        os.makedirs(self.output_dir, exist_ok=True)

    def generate_pdf(self, filename="report.pdf", specific_files=None, bbox=None):
        output_path = os.path.join(self.output_dir, filename)
        c = canvas.Canvas(output_path, pagesize=letter)
        width, height = letter

        # Title
        c.setFont("Helvetica-Bold", 24)
        c.drawString(50, height - 50, "Squad Gamma - NDVI Analysis Report")

        c.setFont("Helvetica", 12)
        c.drawString(50, height - 80, "Generated by Squad Gamma Automated Pipeline")

        # QR Code Generation
        if bbox:
            try:
                # Calculate center
                # BBox is iterable [minx, miny, maxx, maxy] or object with properties
                if hasattr(bbox, 'lower_left'): # sentinelhub.BBox object
                    minx, miny = bbox.lower_left
                    maxx, maxy = bbox.upper_right
                else: # list/tuple
                     minx, miny, maxx, maxy = bbox[0], bbox[1], bbox[2], bbox[3]

                center_lat = (miny + maxy) / 2
                center_lon = (minx + maxx) / 2

                # Geo URI
                qr_data = f"geo:{center_lat},{center_lon}?q={center_lat},{center_lon}(Mission Center)"

                qr = qrcode.QRCode(
                    version=1,
                    error_correction=qrcode.constants.ERROR_CORRECT_L,
                    box_size=10,
                    border=4,
                )
                qr.add_data(qr_data)
                qr.make(fit=True)

                qr_img = qr.make_image(fill_color="black", back_color="white")

                # Save QR to buffer
                qr_buffer = io.BytesIO()
                qr_img.save(qr_buffer, format="PNG")
                qr_buffer.seek(0)

                # Draw QR code in footer
                qr_size = 80
                c.drawImage(ImageReader(qr_buffer), width - qr_size - 50, 50, width=qr_size, height=qr_size)

                c.setFont("Helvetica", 8)
                c.drawString(width - qr_size - 50, 40, "Navigation Scan")

            except Exception as e:
                logger.error(f"Failed to generate QR code: {e}")

        y_position = height - 120

        # Find TIF files
        if specific_files:
            tif_files = specific_files
        else:
            tif_files = glob.glob(os.path.join(self.input_dir, "*_NDVI_analysis.tif"))

        if not tif_files:
            logger.warning("No NDVI files found to generate report.")
            c.drawString(50, y_position, "No data available.")
            c.save()
            return

        for filepath in tif_files:
            try:
                img_buffer = self._create_image_from_tif(filepath)

                if y_position < 300: # New page if low on space
                    c.showPage()
                    y_position = height - 50

                # Draw Image
                img_reader = ImageReader(img_buffer)
                img_w, img_h = 256, 256 # Fixed display size

                # Centered image
                x_pos = (width - img_w) / 2
                c.drawImage(img_reader, x_pos, y_position - img_h, width=img_w, height=img_h)

                # Caption
                c.setFont("Helvetica-Bold", 10)
                filename_only = os.path.basename(filepath)
                c.drawString(50, y_position + 10, f"File: {filename_only}")

                y_position -= (img_h + 50)

            except Exception as e:
                logger.error(f"Failed to process {filepath} for PDF: {e}")
                c.drawString(50, y_position, f"Error processing {os.path.basename(filepath)}")
                y_position -= 30

        c.save()
        logger.info(f"PDF Report generated at {output_path}")

    def _create_image_from_tif(self, filepath):
        with rasterio.open(filepath) as src:
            data = src.read(1)

            # Handling 10,000x Integer Scaling Check
            # If the data is float but clearly has values >> 1 (like 2000, 5000), it's likely scaled.
            # Normal NDVI is -1 to 1.
            # If we see values > 100, we assume it's scaled by 10000.
            # (Using 100 as a safe threshold, assuming no valid NDVI is 100).
            # Note: TIF nodata is often NaN, but could be a specific value.

            # Filter out NaN for min/max check
            valid_data = data[~np.isnan(data)]
            if valid_data.size > 0:
                max_val = np.max(valid_data)
                if max_val > 100: # Arbitrary threshold for "this is definitely not -1 to 1"
                    logger.info(f"Detected scaled integer data in {filepath} (max={max_val}). Dividing by 10,000.")
                    data = data / 10000.0

            # Apply colormap RdYlGn
            # Normalize data to 0-1 range for colormap
            # RdYlGn: Red (low) -> Green (high).
            # NDVI: -1 (water/snow) to 1 (vegetation).
            # Usually we map -1..1 to 0..1.

            norm = colors.Normalize(vmin=-1.0, vmax=1.0)
            cmap = cm.get_cmap('RdYlGn')

            # Map data to colors. masked=True handles NaNs usually, but we need to check
            # if we need to explicitly handle NaNs (make them transparent or specific color)

            # Using matplotlib to map
            colored_data = cmap(norm(data))

            # colored_data is (H, W, 4) float array (0..1)

            # Handle NaNs: make them transparent or white
            # data is the original array.
            # Create a mask for NaN
            nan_mask = np.isnan(data)
            colored_data[nan_mask] = [0, 0, 0, 0] # Transparent

            # Convert to uint8 (0-255)
            img_data = (colored_data * 255).astype(np.uint8)

            # Create PIL Image
            img = Image.fromarray(img_data, 'RGBA')

            # Save to buffer
            buffer = io.BytesIO()
            img.save(buffer, format='PNG')
            buffer.seek(0)

            return buffer

if __name__ == "__main__":
    # Test run
    gen = PDFReportGenerator()
    gen.generate_pdf()
